<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>精彩神捕捉遊戲系統</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        
        /* Theme CSS Variables will be inserted here */
        :root {
  --body-bg: linear-gradient(135deg, #ff7e5f, #feb47b, #84fab0, #8fd3f4);
  --body-text-color: #333333;
  --wrapper-bg: rgba(255, 255, 255, 0.9);
  --wrapper-border: 1px solid rgba(128, 0, 128, 0.3);
  --wrapper-shadow: 0 10px 40px rgba(0, 0, 0, 0.2), 0 0 20px rgba(255, 100, 200, 0.4);
  --wrapper-text-color: #333333;
  --wrapper-h1-color: #8e2de2;
  --canvas-bg: linear-gradient(180deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3);
  --canvas-border: 4px solid #ff1493;
  --canvas-shadow: inset 0 0 15px rgba(255, 20, 147, 0.7);
  --status-item-bg: rgba(0, 0, 0, 0.05);
  --status-item-border: 1px solid rgba(0, 0, 0, 0.1);
  --status-level-bg: rgba(255, 192, 203, 0.2);
  --status-level-border: rgba(255, 192, 203, 0.4);
  --status-timer-bg: rgba(173, 216, 230, 0.2);
  --status-timer-border: rgba(173, 216, 230, 0.4);
  --status-score-bg: rgba(144, 238, 144, 0.2);
  --status-score-border: rgba(144, 238, 144, 0.4);
  --status-level-text: #ff69b4;
  --status-timer-text: #87cefa;
  --status-score-text: #32cd32;
  --mission-bg: rgba(128, 0, 128, 0.4);
  --mission-border: 4px solid #ff69b4;
  --mission-text-color: #333333;
  --mission-h2-color: #8e2de2;
  --mission-target-icon-color: #008000;
  --mission-target-text-color: #008000;
  --mission-forbidden-icon-color: #b22222;
  --mission-forbidden-text-color: #b22222;
  --mission-level-name-color: #696969;
  --button-bg: linear-gradient(145deg, #ff1493, #8a2be2);
  --button-color: #ffffff;
  --button-shadow: 0 4px 15px rgba(255, 20, 147, 0.5), 0 0 20px rgba(138, 43, 226, 0.7);
  --button-hover-shadow: 0 6px 20px rgba(255, 20, 147, 0.8), 0 0 30px rgba(138, 43, 226, 0.9);
  --modal-bg: #f08080;
  --modal-border: 1px solid rgba(255, 100, 200, 0.6);
  --modal-shadow: 0 0 30px rgba(255, 20, 147, 0.6);
  --modal-h2-color: #8a2be2;
  --modal-h3-color: #32cd32;
  --modal-close-color: #ffffff;
  --modal-hover-close-color: #000000;
  --title-instructions-button-color: #ff69b4;
  --title-instructions-button-hover-color: #ff1493;
  --screen-flash-color-capture: rgba(255, 255, 255, 0.6);
  --score-positive-color: #008000;
  --score-negative-color: #b22222;
  --score-bonus-color: #ffd700;
  --particle-positive-color: #ff0000;
  --loading-overlay-bg: linear-gradient(135deg, #ff7e5f, #84fab0);
  --loading-overlay-text-color: #333333;
  --spinner-border-color-light: rgba(255, 255, 255, 0.3);
  --spinner-border-color-dark: #ff1493;
  --score-breakdown-bg: rgba(128, 0, 128, 0.4);
  --score-breakdown-border: 1px solid rgba(255, 100, 200, 0.3);
  --score-breakdown-text-color: #333333;
  --score-breakdown-label-color: #8e2de2;
  --score-breakdown-total-color: #ff1493;
  --score-breakdown-divider-color: rgba(0, 0, 0, 0.3);
  --mascot-hover-shadow-color1: #ff1493;
  --mascot-hover-shadow-color2: #8a2be2;
  --mascot-hover-shadow-color3: #c080ff;
  --mascot-hover-shadow-color4: #ff69b4;
  --copyright-text-color: #696969;
}


        body {
            font-family: 'Inter', sans-serif;
            background: var(--body-bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 1rem;
            color: var(--body-text-color);
            transition: background-color 0.5s;
            position: relative; 
            overflow-x: hidden; /* Prevent horizontal scroll due to particle effects */
        }

        #game-wrapper {
            background-color: var(--wrapper-bg); 
            backdrop-filter: blur(10px); /* 磨砂玻璃效果 */
            -webkit-backdrop-filter: blur(10px); /* 兼容 Safari */
            border-radius: 1.5rem;
            box-shadow: var(--wrapper-shadow);
            width: 95vw;
            max-width: 700px; /* 限制最大寬度，響應式設計 */
            padding: 1.5rem;
            z-index: 10; 
            border: var(--wrapper-border);
            color: var(--wrapper-text-color);
            display: none; /* 初始隱藏，載入完成後顯示 */
        }

        #game-wrapper h1 {
            color: var(--wrapper-h1-color);
        }

        #canvas-container {
            position: relative;
            background: var(--canvas-bg);
            border-radius: 1rem;
            border: var(--canvas-border); 
            overflow: hidden;
            touch-action: none; /* 禁用瀏覽器觸控行為 */
            min-height: 400px; /* 確保容器有高度，避免閃爍 */
            box-shadow: var(--canvas-shadow);
        }
        
        #gameCanvas {
            display: block;
            width: 100%;
            height: 400px;
            cursor: pointer;
        }

        .status-bar-item {
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: bold;
            color: var(--body-text-color); /* Use body text color for consistency */
            background-color: var(--status-item-bg);
            border: var(--status-item-border);
        }
        /* 特殊狀態欄顏色 */
        .status-bar-item#level-display-wrapper { background-color: var(--status-level-bg); border-color: var(--status-level-border); }
        .status-bar-item#level-display-wrapper span:first-child { color: var(--status-level-text); }
        .status-bar-item#timer-display-wrapper { background-color: var(--status-timer-bg); border-color: var(--status-timer-border); }
        .status-bar-item#timer-display-wrapper span:first-child { color: var(--status-timer-text); }
        .status-bar-item#score-display-wrapper { background-color: var(--status-score-bg); border-color: var(--status-score-border); }
        .status-bar-item#score-display-wrapper span:first-child { color: var(--status-score-text); }


        .game-button {
            padding: 0.6rem 2rem;
            background: var(--button-bg);
            color: var(--button-color);
            font-weight: 900;
            font-size: 1.1rem;
            border-radius: 9999px;
            border: none;
            cursor: pointer;
            box-shadow: var(--button-shadow);
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .game-button:hover {
            transform: translateY(-2px);
            box-shadow: var(--button-hover-shadow);
        }

        /* 吉祥物樣式 (頁面左下角固定) */
        #mascot-fixed {
            position: fixed;
            bottom: 10px;
            left: 10px;
            width: 80px; 
            height: auto;
            cursor: pointer;
            z-index: 5; 
            transition: transform 0.2s ease-out, filter 0.2s ease-out; 
        }

        /* 抖動動畫 */
        @keyframes neon-shake {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            10% { transform: translate(-1px, -1px) rotate(-1deg); }
            20% { transform: translate(1px, 1px) rotate(1deg); }
            30% { transform: translate(-1px, 1px) rotate(-1deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, -1px) rotate(-1deg); }
            60% { transform: translate(1px, 1px) rotate(1deg); }
            70% { transform: translate(-1px, 1px) rotate(-1deg); }
            80% { transform: translate(1px, -1px) rotate(1deg); }
            90% { transform: translate(-1px, -1px) rotate(-1deg); }
        }

        #mascot-fixed:hover {
            animation: neon-shake 0.8s infinite linear; 
            filter: drop-shadow(0 0 5px var(--mascot-hover-shadow-color1)) 
                    drop-shadow(0 0 10px var(--mascot-hover-shadow-color2)) 
                    drop-shadow(0 0 15px var(--mascot-hover-shadow-color3)) 
                    drop-shadow(0 0 20px var(--mascot-hover-shadow-color4)); 
        }

        /* 版權資訊樣式 */
        #copyright {
            margin-top: 2rem;
            font-size: 0.9rem;
            color: var(--copyright-text-color);
            text-align: center;
            z-index: 10;
        }

        /* 遊戲說明書樣式 */
        #instructions-modal {
            background-color: rgba(0, 0, 0, 0.85); /* 更深的半透明背景 */
            z-index: 50;
        }
        #instructions-modal .modal-content { /* 自定義 class 避免 Tailwind 衝突 */
            background-color: var(--modal-bg);
            max-height: 90vh;
            overflow-y: auto;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: var(--modal-border);
            box-shadow: var(--modal-shadow);
        }
        #instructions-modal h2 {
            color: var(--modal-h2-color);
        }
        #instructions-modal h3 {
            color: var(--modal-h3-color);
        }
        #instructions-modal button.absolute {
            color: var(--modal-close-color);
        }
        #instructions-modal button.absolute:hover {
            color: var(--modal-hover-close-color);
        }

        /* 遊戲按鈕覆蓋層 */
        #game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 20;
            background: rgba(30,30,50,0.6); /* 輕微背景，讓文字更清晰 */
            border-radius: 1rem;
            transition: opacity 0.3s ease-in-out;
            opacity: 1;
        }

        #game-overlay.hidden {
            opacity: 0;
            pointer-events: none;
            display: none;
        }
        #game-overlay:not(.hidden) {
            display: flex;
        }

        #game-overlay > * {
            pointer-events: auto;
        }

        /* 主標題內的說明按鈕 */
        #title-instructions-button {
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            padding: 0;
            cursor: pointer;
            color: var(--title-instructions-button-color);
            transition: color 0.2s;
        }
        #title-instructions-button:hover {
            color: var(--title-instructions-button-hover-color);
        }
        @media (min-width: 640px) {
            #title-instructions-button {
                right: 1rem;
            }
        }

        /* 物品小圖標在文字中的樣式 */
        .item-icon-inline {
            height: 1.5em;
            width: auto;
            vertical-align: middle;
            margin: 0 0.2em;
            display: inline-block;
        }
        /* 確保每個任務項目的圖片和文字不會斷開 */
        .mission-item-wrapper {
            display: inline-flex;
            align-items: center;
            white-space: nowrap;
            margin-right: 1rem;
        }
        /* 任務目標區的文字 flex 容器 */
        #mission-display .flex-wrap {
            display: flex;
            flex-wrap: wrap;
            gap: 0;
        }

        #mission-display {
            background-color: var(--mission-bg);
            border-left: var(--mission-border);
            color: var(--mission-text-color);
        }
        #mission-display h2 {
            color: var(--mission-h2-color);
        }
        #mission-display .fa-camera-retro {
            color: var(--mission-target-icon-color);
        }
        #mission-display #targets {
            color: var(--mission-target-text-color);
        }
        #mission-display .fa-ban {
            color: var(--mission-forbidden-icon-color);
        }
        #mission-display #forbidden {
            color: var(--mission-forbidden-text-color);
        }
        #mission-display #level-name {
            color: var(--mission-level-name-color);
        }

        /* Background Music Control Area - REMOVED */

        /* Loading Overlay */
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--loading-overlay-bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--loading-overlay-text-color);
            font-size: 1.5rem;
            font-weight: bold;
            z-index: 100;
            transition: opacity 0.5s ease;
        }
        #loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .spinner {
            border: 4px solid var(--spinner-border-color-light);
            border-top: 4px solid var(--spinner-border-color-dark);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 1rem;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Score breakdown style */
        #score-breakdown {
            margin-top: 1rem;
            background-color: var(--score-breakdown-bg);
            padding: 1rem;
            border-radius: 0.75rem;
            border: var(--score-breakdown-border);
            font-size: 1rem;
            color: var(--score-breakdown-text-color);
            text-align: left;
            width: 80%;
            max-width: 300px;
        }
        #score-breakdown p {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.3rem;
        }
        #score-breakdown p span:first-child {
            color: var(--score-breakdown-label-color);
        }
        #score-breakdown .total-score {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--score-breakdown-total-color);
            border-top: 1px dashed var(--score-breakdown-divider-color);
            padding-top: 0.5rem;
            margin-top: 0.5rem;
        }

    </style>
</head>
<body>
    <!-- Loading Overlay -->
    <div id="loading-overlay">
        <div class="spinner"></div>
        <p>載入中，請稍候...</p>
    </div>

    <div id="game-wrapper">
        <h1 class="text-3xl font-extrabold mb-4 text-center relative">
            精彩神捕捉遊戲系統 
            <button id="title-instructions-button">
                <i class="fas fa-info-circle text-2xl"></i>
            </button>
        </h1>
        
        <!-- 狀態欄：關卡、時間、分數 -->
        <div class="flex justify-between items-center mb-4 p-2 rounded-xl">
            <div id="level-display-wrapper" class="status-bar-item"><span class="">關卡:</span> <span id="level-display">0</span></div>
            <div id="timer-display-wrapper" class="status-bar-item text-2xl"><span class="">時間:</span> <span id="timer-display">0.0</span>s</div>
            <div id="score-display-wrapper" class="status-bar-item"><span class="">得分:</span> <span id="score-display">0</span></div>
        </div>

        <!-- 任務目標區 -->
        <div id="mission-display" class="mb-4 p-4 rounded-lg">
            <h2 class="text-xl font-bold mb-2"><i class="fas fa-bullseye"></i> 任務目標:</h2>
            <div class="flex flex-wrap text-lg">
                <p><i class="fas fa-camera-retro"></i> 捕捉: <span id="targets" class="font-bold">...</span></p>
                <p class="ml-4"><i class="fas fa-ban"></i> 避開: <span id="forbidden" class="font-bold">...</span></p>
            </div>
            <p id="level-name" class="text-sm mt-2 italic">遊戲尚未開始</p>
        </div>

        <!-- 畫布容器 -->
        <div id="canvas-container">
            <canvas id="gameCanvas"></canvas>
            <!-- 遊戲訊息與按鈕覆蓋層 -->
            <div id="game-overlay">
                <p id="game-message" class="text-lg text-white mb-4 text-center drop-shadow-lg"></p>
                <!-- Score breakdown will be inserted here dynamically -->
                <div id="score-breakdown" class="hidden"></div> 
                <button id="start-button" class="game-button"></button>
            </div>
        </div>

    </div>

    <!-- 背景音樂控制區 - REMOVED -->

    <!-- 吉祥物圖片 (頁面左下角固定) -->
    <img id="mascot-fixed" src="image/LiyuChillGuy.svg" alt="吉祥物 LiyuChillGuy" onerror="this.style.display='none';">

    <!-- 版權資訊 -->
    <div id="copyright">
        <p>Copyright © Liyuchiutiger Gongminshen</p>
    </div>

    <!-- 遊戲說明書 Modal -->
    <div id="instructions-modal" class="fixed inset-0 flex items-center justify-center p-4 hidden z-50">
        <div class="modal-content rounded-lg p-6 max-w-lg w-full text-white shadow-xl relative">
            <h2 class="text-2xl font-bold mb-4"><i class="fas fa-gamepad"></i> 遊戲說明</h2>
            <button class="absolute top-3 right-3 text-3xl font-bold" onclick="gameInstance.toggleInstructions()">×</button>
            
            <p class="mb-3">歡迎來到捕捉挑戰！你的任務是在限時內，捕捉到關卡指定的所有「目標」，同時「避開」所有禁忌物品。</p>
            
            <h3 class="text-xl font-bold mt-4 mb-2"><i class="fas fa-crosshairs"></i> 如何遊玩:</h3>
            <ul class="list-disc list-inside mb-3 space-y-1">
                <li>遊戲區域內會漂浮著各種物品。</li>
                <li>點擊畫面任何位置，即會觸發一次「全螢幕快照」。</li>
                <li><strong class="text-red-400">如果快照中出現任何禁忌物品，你將立即失敗！</strong></li>
                <li id="instructions-forbidden-list" class="flex flex-wrap pl-5 mb-2">
                    <!-- Dynamic forbidden items will be inserted here. Note: global forbidden items are removed. -->
                    請在關卡設定中查看具體禁忌物品。
                </li>
                <li>如果快照中同時出現所有「任務目標」，且沒有任何禁忌物品，你將成功晉級！</li>
                <li>捕捉獎勵物品可獲得額外獎勵分數，但僅限在成功晉級的回合！</li>
                <li>點擊「下一關」或「再試一次」才會讓物件重新移動。如果快照沒有導致晉級或失敗，會出現「繼續捕捉」按鈕，點擊後物件也會恢復移動。</li>
            </ul>

            <h3 class="text-xl font-bold mt-4 mb-2"><i class="fas fa-star"></i> 遊戲提示:</h3>
            <ul class="list-disc list-inside space-y-1">
                <li>每個關卡的時間和目標都不同，請仔細查看。</li>
                <li>遊戲會隨著關卡推進而增加難度，物品移動速度會變快！</li>
                <li>精準判斷快照時機是獲勝的關鍵！</li>
            </ul>
            <button class="game-button mt-6 w-full" onclick="gameInstance.toggleInstructions()">我知道了！</button>
        </div>
    </div>

    <!-- 背景音樂 Audio Element - REMOVED -->

    <script>
        // --- 遊戲全局配置 ---
        const SCALE_FACTOR = 2;
        const SCORE_PER_CAPTURE = 100;
        const BONUS_ITEM_SCORE = 200;
        const TIME_BONUS_MULTIPLIER = 50; // 每秒剩餘時間的分數
        const TARGET_BONUS_PER_ITEM = 50; // 每捕捉一個目標的額外分數 (如果有多個目標)

        const ORIGINAL_IMAGE_DEFINITIONS = {
    "ITEM_KEY_E2D13": {
        "path": "item/item001.svg",
        "size": 70,
        "speed": 2,
        "name": "炸蛋",
        "isBonus": false
    },
    "ITEM_KEY_2D3B7E68": {
        "path": "item/item002.svg",
        "size": 55,
        "speed": 1,
        "name": "快樂鯉魚",
        "isBonus": true
    },
    "ITEM_KEY_CC8A6": {
        "path": "item/item003.svg",
        "size": 60,
        "speed": 0.5,
        "name": "月亮",
        "isBonus": false
    },
    "ITEM_KEY_E4EEB": {
        "path": "item/item004.svg",
        "size": 40,
        "speed": 1,
        "name": "玉兔",
        "isBonus": false
    },
    "ITEM_KEY_10066D": {
        "path": "item/item005.svg",
        "size": 50,
        "speed": 2.5,
        "name": "老虎",
        "isBonus": false
    }
};
        const OBJECT_TYPES = {}; 

        

        const LEVELS = [
    {
        "name": "入門捕手",
        "duration": 15,
        "required": [
            "ITEM_KEY_CC8A6"
        ],
        "forbidden": [
            "ITEM_KEY_E2D13"
        ],
        "objectCount": 8,
        "speedMultiplier": 1,
        "bonusItemChance": 0.2
    },
    {
        "name": "雙重挑戰",
        "duration": 12,
        "required": [
            "ITEM_KEY_CC8A6",
            "ITEM_KEY_E4EEB"
        ],
        "forbidden": [
            "ITEM_KEY_E2D13",
            "ITEM_KEY_10066D"
        ],
        "objectCount": 12,
        "speedMultiplier": 1.3,
        "bonusItemChance": 0.3
    },
    {
        "name": "終極追逐",
        "duration": 10,
        "required": [
            "ITEM_KEY_CC8A6",
            "ITEM_KEY_E4EEB"
        ],
        "forbidden": [
            "ITEM_KEY_E2D13",
            "ITEM_KEY_10066D"
        ],
        "objectCount": 15,
        "speedMultiplier": 1.6,
        "bonusItemChance": 0.4
    }
];

        // Helper to get CSS variable value
        function getCssVariable(variableName) {
            const value = getComputedStyle(document.documentElement).getPropertyValue(variableName).trim();
            if (!value) {
                console.warn(`CSS variable ${variableName} not found or empty.`);
                return 'transparent'; // Fallback to transparent or a default color
            }
            return value;
        }

        // --- 遊戲對象類別 ---
        class GameObject {
            constructor(typeId, canvasWidth, canvasHeight) { // 傳入畫布尺寸
                const typeDef = OBJECT_TYPES[typeId]; 
                this.typeId = typeId;
                this.img = typeDef.img; 
                this.size = typeDef.size; 
                // 讓物件從畫布邊緣外出現
                this.x = Math.random() * canvasWidth;
                this.y = Math.random() < 0.5 ? -this.size : canvasHeight + this.size; 
                this.baseSpeed = typeDef.speed;
                this.vx = (Math.random() - 0.5) * 0.5; // 隨機水平速度
                this.vy = this.y < canvasHeight / 2 ? 1 : -1; // 根據出現位置決定初始垂直方向
                this.isBonus = typeDef.isBonus || false; 
                this.name = typeDef.name; 
                this.canvasWidth = canvasWidth;
                this.canvasHeight = canvasHeight;
            }

            isVisibleOnCanvas() {
                // 判斷物件是否至少部分在畫布內
                return (
                    this.x + this.size / 2 > 0 && 
                    this.x - this.size / 2 < this.canvasWidth && 
                    this.y + this.size / 2 > 0 && 
                    this.y - this.size / 2 < this.canvasHeight
                );
            }

            update(speedMultiplier) {
                if (gameInstance.objectsAreFrozen) return; 

                this.x += this.vx * this.baseSpeed * speedMultiplier;
                this.y += this.vy * this.baseSpeed * speedMultiplier;

                // 邊界反彈
                if (this.x - this.size / 2 < 0 || this.x + this.size / 2 > this.canvasWidth) {
                    this.vx *= -1;
                    // Prevent sticking to edges
                    if (this.x - this.size / 2 < 0) this.x = this.size / 2;
                    if (this.x + this.size / 2 > this.canvasWidth) this.x = this.canvasWidth - this.size / 2;
                }
            }

            isOffScreen() {
                // 判斷物件是否完全離開畫面
                return (this.y < -this.size * 2 || this.y > this.canvasHeight + this.size * 2);
            }

            draw() {
                // 只有當圖片載入成功時才繪製
                if (!this.img) {
                    gameInstance.ctx.fillStyle = 'gray';
                    gameInstance.ctx.fillRect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size);
                    gameInstance.ctx.fillStyle = 'white';
                    gameInstance.ctx.font = `${this.size/3}px Arial`;
                    gameInstance.ctx.fillText(this.name, this.x, this.y);
                    return;
                }

                gameInstance.ctx.save();
                gameInstance.ctx.textAlign = 'center';
                gameInstance.ctx.textBaseline = 'middle';
                gameInstance.ctx.globalAlpha = 1.0; 
                
                gameInstance.ctx.drawImage(this.img, this.x - this.size / 2, this.y - this.size / 2, this.size, this.size);
                
                gameInstance.ctx.restore();
            }
        }

        // --- Game Class ---
        class Game {
            constructor() {
                // DOM Elements
                this.loadingOverlay = document.getElementById('loading-overlay');
                this.gameWrapper = document.getElementById('game-wrapper');
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.timerDisplay = document.getElementById('timer-display');
                this.levelDisplay = document.getElementById('level-display');
                this.scoreDisplay = document.getElementById('score-display');
                this.targetsDisplay = document.getElementById('targets');
                this.forbiddenDisplay = document.getElementById('forbidden');
                this.levelNameDisplay = document.getElementById('level-name');
                this.gameMessage = document.getElementById('game-message');
                this.startButton = document.getElementById('start-button');
                this.gameOverlay = document.getElementById('game-overlay');
                this.instructionsModal = document.getElementById('instructions-modal');
                this.titleInstructionsButton = document.getElementById('title-instructions-button');
                this.instructionsForbiddenList = document.getElementById('instructions-forbidden-list'); // This element will just show a note
                this.scoreBreakdownElement = document.getElementById('score-breakdown'); // New element

                // Audio Elements - BGM removed
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)(); // Still needed for capture/bonus sound effects
                
                // Game State Variables
                this.canvasWidth = 0;
                this.canvasHeight = 400; // 固定高度
                this.gameState = 'ready'; // 'ready', 'playing', 'win', 'lose'
                this.gameObjects = [];
                this.score = 0; // Total accumulated score
                this.currentLevelScore = 0; // Score for the current level
                this.currentLevelIndex = 0;
                this.captureEffect = null;
                this.highlightEffect = null; // { type: 'success' | 'failure' | 'neutral', items: [{ obj: GameObject, color: string }], startTime: number }
                this.bonusMessages = [];
                this.objectsAreFrozen = false;
                this.animationFrameId = null;

                // Time Management for rAF
                this.gameStartTime = 0;
                this.lastFrameTime = 0;
                this.timeLeft = 0;

                // Asset Loading
                this.totalImagesToLoad = Object.keys(ORIGINAL_IMAGE_DEFINITIONS).length;
                this.imagesLoadedCount = 0;
                this.imagesLoadedMap = {}; // Use a map to store loaded Image objects
                this.fontAwesomeLoaded = false;
                this.mascotLoaded = false;
            }

            // --- Initialization and Asset Loading ---
            async init() {
                this.setupEventListeners();
                // this.resizeCanvas(); // Initial resize - will be called after gameWrapper is displayed
                window.addEventListener('resize', () => this.resizeCanvas());

                // Load Font Awesome
                document.fonts.ready.then(() => {
                    this.fontAwesomeLoaded = true;
                    this.checkAllAssetsLoaded();
                }).catch(err => {
                    console.error("Font Awesome 字體載入失敗:", err);
                    this.fontAwesomeLoaded = true; // Assume loaded to avoid blocking
                    this.checkAllAssetsLoaded();
                });

                // Load Mascot Image (just check existence)
                const mascotImg = document.getElementById('mascot-fixed');
                // No need to create new Image if it's already in DOM, just check its `complete` status
                if (mascotImg && mascotImg.complete) { // Check if mascotImg exists
                    this.mascotLoaded = true;
                    this.checkAllAssetsLoaded();
                } else if (mascotImg) {
                    mascotImg.onload = () => {
                        this.mascotLoaded = true;
                        this.checkAllAssetsLoaded();
                    };
                    mascotImg.onerror = () => {
                        console.warn("吉祥物圖片載入失敗.");
                        this.mascotLoaded = true; // Still mark as loaded to not block game
                        this.checkAllAssetsLoaded();
                    };
                } else { // Mascot image element not found
                    this.mascotLoaded = true; // Mark as loaded to not block
                    this.checkAllAssetsLoaded();
                }


                // Pre-populate OBJECT_TYPES with definitions and miniHtmlImg
                for (const key in ORIGINAL_IMAGE_DEFINITIONS) {
                    OBJECT_TYPES[key] = { 
                        ...ORIGINAL_IMAGE_DEFINITIONS[key], 
                        miniHtmlImg: `<img src="${ORIGINAL_IMAGE_DEFINITIONS[key].path}" alt="${ORIGINAL_IMAGE_DEFINITIONS[key].name}" class="item-icon-inline">`
                    };
                }

                // Load Game Object Images
                for (const key in ORIGINAL_IMAGE_DEFINITIONS) {
                    const img = new Image();
                    img.src = ORIGINAL_IMAGE_DEFINITIONS[key].path;
                    img.onload = () => {
                        this.imagesLoadedMap[key] = img;
                        this.imagesLoadedCount++;
                        this.checkAllAssetsLoaded();
                    };
                    img.onerror = () => {
                        console.warn(`圖片載入失敗: ${ORIGINAL_IMAGE_DEFINITIONS[key].path}。此物件可能無法顯示。`);
                        this.imagesLoadedMap[key] = null; // Store null if failed
                        this.imagesLoadedCount++;
                        this.checkAllAssetsLoaded();
                    };
                }
            }

            checkAllAssetsLoaded() {
                // FontAwesome and Mascot are 2 extra assets to track
                const totalExpectedLoads = this.totalImagesToLoad + 2; 
                const currentLoads = this.imagesLoadedCount + (this.fontAwesomeLoaded ? 1 : 0) + (this.mascotLoaded ? 1 : 0);

                if (currentLoads === totalExpectedLoads) {
                    // Assign loaded Image objects to OBJECT_TYPES
                    for (const key in ORIGINAL_IMAGE_DEFINITIONS) {
                        OBJECT_TYPES[key].img = this.imagesLoadedMap[key];
                    }
                    this.loadingOverlay.classList.add('hidden');
                    this.gameWrapper.style.display = 'block'; // Show game wrapper
                    this.resizeCanvas(); // <<<<<<<<<<<<<<<<<<<<<<<< ADDED THIS LINE: Ensure canvas is resized AFTER its wrapper is displayed
                    this.postLoadSetup();
                }
            }

            postLoadSetup() {
                this.score = 0;
                this.currentLevelIndex = 0;
                this.scoreDisplay.textContent = this.score;
                this.gameMessage.textContent = '點擊開始按鈕，捕捉目標！';
                this.startButton.textContent = '開始挑戰';
                this.startButton.onclick = () => this.startGame(); 
                this.gameOverlay.classList.remove('hidden'); 
                this.scoreBreakdownElement.classList.add('hidden'); // Hide breakdown
                this.gameState = 'ready';
                this.objectsAreFrozen = false; 
                this.highlightEffect = null; 
                this.clearScreen();
                
                // Ensure there is at least one level
                if (LEVELS.length > 0) {
                    this.updateMissionDisplay(LEVELS[this.currentLevelIndex]);
                    // Instructions modal forbidden list is now just a static note
                    document.getElementById('instructions-forbidden-list').innerHTML = '請在關卡設定中查看具體禁忌物品。';
                } else {
                    this.targetsDisplay.innerHTML = '無';
                    this.forbiddenDisplay.innerHTML = '無';
                    this.levelNameDisplay.textContent = '沒有定義關卡！';
                    this.gameMessage.textContent = '沒有設定關卡，無法開始遊戲！';
                    this.startButton.disabled = true;
                }
                
                // Start the game loop after everything is loaded and set up
                if (!this.animationFrameId) {
                    this.animationFrameId = requestAnimationFrame(this.drawGame.bind(this));
                }
            }

            // --- Event Listeners ---
            setupEventListeners() {
                this.canvas.addEventListener('mousedown', (e) => this.handleCapture(this.getMousePos(e)));
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault(); // Prevent scrolling on mobile
                    this.handleCapture(this.getMousePos(e));
                }, { passive: false });
                this.titleInstructionsButton.onclick = () => this.toggleInstructions();
            }

            getMousePos(e) {
                const rect = this.canvas.getBoundingClientRect();
                let clientX, clientY;
                if (e.touches && e.touches.length > 0) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                return {
                    x: clientX - rect.left,
                    y: clientY - rect.top
                };
            }

            resizeCanvas() {
                const container = this.canvas.parentElement;
                this.canvasWidth = container.clientWidth;
                this.canvas.width = this.canvasWidth;
                this.canvas.height = this.canvasHeight; // Ensure canvas dimensions are set
            }

            // --- Sound Control ---
            playSound(frequency, duration, type = 'sine', decayTime = 0.1, volume = 0.5) {
                if (!this.audioContext || this.audioContext.state === 'suspended') {
                    this.audioContext.resume().then(() => {
                        this._createAndPlayOscillator(frequency, duration, type, decayTime, volume);
                    });
                } else {
                    this._createAndPlayOscillator(frequency, duration, type, decayTime, volume);
                }
            }

            _createAndPlayOscillator(frequency, duration, type, decayTime, volume) {
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                oscillator.type = type; 
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                gainNode.gain.setValueAtTime(volume, this.audioContext.currentTime); 
                gainNode.gain.exponentialRampToValueAtTime(0.0001, this.audioContext.currentTime + decayTime);
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + duration);
            }

            // --- Game Logic ---
            startGame() {
                this.currentLevelIndex = 0; 
                this.score = 0; // Reset total score for a new game
                this.scoreDisplay.textContent = this.score;
                this.initLevel(this.currentLevelIndex);
            }

            resumeCapturing() {
                this.objectsAreFrozen = false; 
                this.gameOverlay.classList.add('hidden'); 
                this.gameMessage.textContent = `關卡 ${this.currentLevelIndex + 1}: ${LEVELS[this.currentLevelIndex].name} - 倒數繼續!`; 
                this.highlightEffect = null; // Clear highlight when resuming game
                this.scoreBreakdownElement.classList.add('hidden'); // Hide breakdown
                this.gameStartTime = performance.now() - (LEVELS[this.currentLevelIndex].duration - this.timeLeft) * 1000; // Adjust start time to resume countdown
            }

            initLevel(levelIndex) {
                if (levelIndex >= LEVELS.length) {
                    this.gameState = 'win';
                    // Final game win message and score breakdown
                    this.gameMessage.innerHTML = `<span class="text-yellow-300 font-bold">🎉 恭喜! 完成所有挑戰!</span>`;
                    this.displayScoreBreakdown(true); // Show final score breakdown
                    this.startButton.textContent = '重新開始 (關卡 1)';
                    this.startButton.onclick = () => this.startGame();
                    this.gameOverlay.classList.remove('hidden'); 
                    this.objectsAreFrozen = true; 
                    return;
                }

                const level = LEVELS[levelIndex];
                this.currentLevelIndex = levelIndex; 
                this.currentLevelScore = 0; // Reset current level score
                
                this.gameObjects = []; 
                this.timeLeft = level.duration;
                this.timerDisplay.textContent = this.timeLeft.toFixed(1);
                
                // 1. Add required and forbidden items
                const initialObjectIds = new Set();
                const allForbidden = level.forbidden || []; // Forbidden items are now *only* from the level config
                
                [...(level.required || []), ...allForbidden].forEach(id => {
                    if (OBJECT_TYPES[id] && OBJECT_TYPES[id].img && !initialObjectIds.has(id)) { 
                        this.gameObjects.push(new GameObject(id, this.canvasWidth, this.canvasHeight));
                        initialObjectIds.add(id);
                    } else if (!OBJECT_TYPES[id] || !OBJECT_TYPES[id].img) {
                        console.warn(`Required/Forbidden item ${id} has no valid image.`);
                    }
                });

                // 2. Add bonus items with a chance
                const bonusKey = Object.keys(OBJECT_TYPES).find(key => OBJECT_TYPES[key].isBonus); // Find any bonus item
                if (bonusKey && Math.random() < (level.bonusItemChance || 0)) { // Use level's chance or default to 0
                    if (OBJECT_TYPES[bonusKey] && OBJECT_TYPES[bonusKey].img && !initialObjectIds.has(bonusKey)) { 
                        this.gameObjects.push(new GameObject(bonusKey, this.canvasWidth, this.canvasHeight));
                        initialObjectIds.add(bonusKey);
                    }
                }

                // 3. Fill remaining slots with other random objects (filler items)
                const fillerCount = level.objectCount - this.gameObjects.length;
                for (let i = 0; i < fillerCount; i++) {
                    const randomFillerTypeId = this.getRandomFillerItem(level);
                    if (randomFillerTypeId) { 
                         this.gameObjects.push(new GameObject(randomFillerTypeId, this.canvasWidth, this.canvasHeight));
                    }
                }
                
                this.gameObjects = this.gameObjects.filter(obj => obj.img !== null);


                this.updateMissionDisplay(level);
                this.levelDisplay.textContent = levelIndex + 1;
                this.gameMessage.textContent = `關卡 ${levelIndex + 1}: ${level.name} - 倒數開始!`; 
                this.gameOverlay.classList.add('hidden'); 
                this.scoreBreakdownElement.classList.add('hidden'); // Hide breakdown for new level
                
                this.gameState = 'playing';
                this.objectsAreFrozen = false; 
                this.highlightEffect = null; 
                this.gameStartTime = performance.now(); // Reset timer
            }

            // Dynamically update the mission display area
            updateMissionDisplay(level) {
                const getMissionItemsElements = (itemIds) => {
                    const fragment = document.createDocumentFragment();
                    itemIds.forEach(id => {
                        const objDef = OBJECT_TYPES[id]; 
                        // Only create elements if objDef and its miniHtmlImg are available
                        if (objDef && objDef.miniHtmlImg && objDef.name) {
                            const wrapper = document.createElement('span');
                            wrapper.classList.add('mission-item-wrapper');
                            // Using innerHTML here for simplicity of already formatted miniHtmlImg
                            wrapper.innerHTML = objDef.miniHtmlImg + ' ' + objDef.name; 
                            fragment.appendChild(wrapper);
                        }
                    });
                    return fragment;
                };
                
                this.targetsDisplay.innerHTML = ''; // Clear previous content
                this.targetsDisplay.appendChild(getMissionItemsElements(level.required || [])); // Ensure it's an array

                this.forbiddenDisplay.innerHTML = ''; // Clear previous content
                // Use combined forbidden items for display
                const allForbidden = level.forbidden || []; // No global forbidden items
                this.forbiddenDisplay.appendChild(getMissionItemsElements(allForbidden));
                
                this.levelNameDisplay.textContent = `限時 ${level.duration} 秒，拍到所有目標即可晉級！`;
            }

            // Instructions modal forbidden list is now just a static note, no dynamic update needed.
            // updateInstructionsForbiddenList() {
            //     document.getElementById('instructions-forbidden-list').innerHTML = '請在關卡設定中查看具體禁忌物品。';
            // }

            handleCapture(pos) { 
                if (this.gameState !== 'playing' || this.objectsAreFrozen) return; 

                this.captureEffect = { x: pos.x, y: pos.y, startTime: performance.now() };
                this.playSound(300, 0.05, 'square', 0.02); 

                const level = LEVELS[this.currentLevelIndex];
                let visibleTargetsDetected = new Set();    
                let visibleForbiddenDetected = new Set();  
                let visibleBonusItemsDetectedCount = 0;        
                
                let itemsCaughtInSnapshot = []; // Store all relevant items caught in this snapshot for highlighting

                // First pass: identify all visible items and categorize them
                for (const obj of this.gameObjects) {
                    if (obj.isVisibleOnCanvas()) { 
                        if ((level.required || []).includes(obj.typeId)) { 
                            visibleTargetsDetected.add(obj.typeId);
                            itemsCaughtInSnapshot.push({ obj: obj, color: '--score-positive-color' }); // Store CSS variable name
                        } else if ((level.forbidden || []).includes(obj.typeId)) { 
                            visibleForbiddenDetected.add(obj.typeId);
                            itemsCaughtInSnapshot.push({ obj: obj, color: '--score-negative-color' }); // Store CSS variable name
                        } else if (obj.isBonus) { 
                            visibleBonusItemsDetectedCount++;
                            itemsCaughtInSnapshot.push({ obj: obj, color: '--score-bonus-color' }); // Store CSS variable name
                        }
                    }
                }

                let isCurrentSnapshotSuccessful = false;
                let failureReason = null;
                let highlightType = 'neutral'; // 'success', 'failure', 'neutral'

                if (visibleForbiddenDetected.size > 0) {
                    // Failure: forbidden items detected
                    failureReason = `捕捉到禁忌物品：${Array.from(visibleForbiddenDetected).map(id => OBJECT_TYPES[id].name).join('、')}！`;
                    highlightType = 'failure';
                    // All caught items will be highlighted, but the message indicates failure due to forbidden.
                } else { 
                    // No forbidden items, check for success condition
                    const currentLevelRequiredTargets = level.required || [];
                    const allRequiredTargetsVisible = currentLevelRequiredTargets.length > 0 && currentLevelRequiredTargets.every(reqId => visibleTargetsDetected.has(reqId));

                    if (allRequiredTargetsVisible) {
                        // Success: all required targets visible
                        isCurrentSnapshotSuccessful = true; 
                        highlightType = 'success';
                        // For success, ensure targets are green, bonuses are gold.
                        // ItemsCaughtInSnapshot already has these colors, no need to re-assign for success.
                    } else {
                        // Neither success nor failure (continue capturing)
                        isCurrentSnapshotSuccessful = false; 
                        highlightType = 'neutral';
                        // In this case, itemsCaughtInSnapshot already has the correct tentative colors.
                    }
                }
                
                this.objectsAreFrozen = true; 
                console.log("Captured. Setting highlightEffect:", highlightType, itemsCaughtInSnapshot); // Debug log

                if (isCurrentSnapshotSuccessful || failureReason !== null) {
                    // Score calculation and level end logic
                    let levelScoreBreakdown = {
                        base: 0,
                        timeBonus: 0,
                        targetBonus: 0,
                        bonusItems: 0,
                        total: 0
                    };

                    if (isCurrentSnapshotSuccessful) {
                        levelScoreBreakdown.base = SCORE_PER_CAPTURE;
                        this.currentLevelScore += SCORE_PER_CAPTURE;

                        const bonusItemPoints = visibleBonusItemsDetectedCount * BONUS_ITEM_SCORE;
                        levelScoreBreakdown.bonusItems = bonusItemPoints;
                        this.currentLevelScore += bonusItemPoints;
                        if (bonusItemPoints > 0) {
                            this.gameObjects.filter(obj => obj.isBonus && obj.isVisibleOnCanvas()).forEach(bonusObj => {
                                this.displayBonusMessage(bonusObj.x, bonusObj.y, BONUS_ITEM_SCORE);
                            });
                        }

                        const timeBonus = Math.max(0, Math.floor(this.timeLeft)) * TIME_BONUS_MULTIPLIER;
                        levelScoreBreakdown.timeBonus = timeBonus;
                        this.currentLevelScore += timeBonus;

                        const targetBonus = visibleTargetsDetected.size * TARGET_BONUS_PER_ITEM;
                        levelScoreBreakdown.targetBonus = targetBonus;
                        this.currentLevelScore += targetBonus;

                        this.score += this.currentLevelScore; 
                    }

                    levelScoreBreakdown.total = this.currentLevelScore; 

                    this.scoreDisplay.textContent = this.score; 
                    this.checkLevelEnd(isCurrentSnapshotSuccessful, failureReason, itemsCaughtInSnapshot, levelScoreBreakdown, highlightType); // Pass all relevant items for highlighting
                } else {
                    // This is the "continue capturing" path for when snapshot is neither success nor failure
                    this.gameMessage.innerHTML = `<span class="text-gray-400">快照完成！還需努力！</span>`;
                    this.startButton.textContent = '繼續捕捉';
                    this.startButton.onclick = () => this.resumeCapturing();
                    this.gameOverlay.classList.remove('hidden'); 
                    this.scoreBreakdownElement.classList.add('hidden'); 
                    // Set highlightEffect to show items caught, with their determined colors
                    this.highlightEffect = { type: highlightType, items: itemsCaughtInSnapshot, startTime: performance.now() }; 
                }
            }


            checkLevelEnd(success, reason = null, highlightItems = [], levelScoreBreakdown = null, highlightType = 'neutral') { // Added highlightType parameter
                this.gameOverlay.classList.remove('hidden'); 
                this.highlightEffect = { type: highlightType, items: highlightItems, startTime: performance.now() }; // Use the passed highlightType and items
                
                if (success) {
                    this.gameMessage.innerHTML = `<span class="text-green-400 font-bold"><i class="fas fa-trophy"></i> 捕捉成功!</span>`;
                    this.displayScoreBreakdown(false, levelScoreBreakdown); // Show breakdown for successful level
                    this.startButton.textContent = '下一關';
                    this.startButton.onclick = () => {
                        this.highlightEffect = null; 
                        this.initLevel(this.currentLevelIndex + 1);
                    };
                    this.playSound(800, 0.15, 'sine', 0.1); 
                    
                } else {
                    this.gameState = 'lose';
                    this.gameMessage.innerHTML = `<span class="text-red-400 font-bold"><i class="fas fa-times-circle"></i> 任務失敗!</span> ${reason ? '原因: ' + reason : '時間用盡了!'}`;
                    this.scoreBreakdownElement.classList.add('hidden'); // Hide breakdown on failure
                    this.startButton.textContent = '再試一次';
                    this.startButton.onclick = () => {
                        this.highlightEffect = null; 
                        this.initLevel(this.currentLevelIndex);
                    };
                    this.playSound(150, 0.2, 'square', 0.1); 
                }
            }

            displayScoreBreakdown(isFinalGameEnd = false, levelScoreBreakdown = null) {
                this.scoreBreakdownElement.innerHTML = ''; // Clear previous content
                this.scoreBreakdownElement.classList.remove('hidden');

                if (isFinalGameEnd) {
                    // Final game end - show total score only
                    const totalP = document.createElement('p');
                    totalP.classList.add('total-score');
                    totalP.innerHTML = `<span>遊戲總分</span> <span>${this.score}</span>`;
                    this.scoreBreakdownElement.appendChild(totalP);
                } else if (levelScoreBreakdown) {
                    // Level success - show breakdown for current level
                    const baseP = document.createElement('p');
                    baseP.innerHTML = `<span>基礎分</span> <span>+${levelScoreBreakdown.base}</span>`;
                    this.scoreBreakdownElement.appendChild(baseP);

                    const timeP = document.createElement('p');
                    timeP.innerHTML = `<span>時間獎勵 (剩餘 ${Math.max(0, Math.floor(this.timeLeft))}秒)</span> <span>+${levelScoreBreakdown.timeBonus}</span>`;
                    this.scoreBreakdownElement.appendChild(timeP);

                    const targetP = document.createElement('p');
                    targetP.innerHTML = `<span>目標數量獎勵</span> <span>+${levelScoreBreakdown.targetBonus}</span>`;
                    this.scoreBreakdownElement.appendChild(targetP);

                    const bonusP = document.createElement('p');
                    bonusP.innerHTML = `<span>獎勵物品分</span> <span>+${levelScoreBreakdown.bonusItems}</span>`;
                    this.scoreBreakdownElement.appendChild(bonusP);

                    const totalP = document.createElement('p');
                    totalP.classList.add('total-score');
                    totalP.innerHTML = `<span>本關得分</span> <span>${levelScoreBreakdown.total}</span>`;
                    this.scoreBreakdownElement.appendChild(totalP);
                }
            }


            displayBonusMessage(x, y, points) {
                this.bonusMessages.push({
                    x: x,
                    y: y,
                    text: `+${points} BONUS!`,
                    startTime: performance.now(),
                    color: getCssVariable('--particle-positive-color') 
                });
                this.playSound(600, 0.1, 'sine', 0.05); 
            }

            // --- Drawing and Animation Loop ---
            clearScreen() {
                this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
                // Attempt to get the CSS variable, fallback if not found or invalid
                const canvasBgStyle = getComputedStyle(document.documentElement).getPropertyValue('--canvas-bg');
                let bgColor = '#1c1c4e'; // Default fallback

                if (canvasBgStyle && canvasBgStyle.includes('linear-gradient')) {
                    // Extract the first color from the linear-gradient definition
                    const match = canvasBgStyle.match(/linear-gradient\(.+?,?\s*([^,)]+)/);
                    if (match && match[1]) {
                        bgColor = match[1].trim();
                    }
                } else if (canvasBgStyle) {
                    bgColor = canvasBgStyle.trim();
                }
                
                this.ctx.fillStyle = bgColor;
                this.ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);
            }

            updateGameTime(currentTime) {
                if (this.gameState === 'playing' && !this.objectsAreFrozen) {
                    const elapsed = (currentTime - this.gameStartTime) / 1000;
                    this.timeLeft = LEVELS[this.currentLevelIndex].duration - elapsed;
                    
                    if (this.timeLeft <= 0) {
                        this.timeLeft = 0;
                        this.timerDisplay.textContent = '0.0';
                        this.checkLevelEnd(false); // Time's up
                        return;
                    }
                    this.timerDisplay.textContent = this.timeLeft.toFixed(1);
                }
            }

            drawGame(currentTime) {
                if (!this.lastFrameTime) this.lastFrameTime = currentTime;
                // const deltaTime = currentTime - this.lastFrameTime; // Delta time for framerate independent updates, currently not used for object movement
                this.lastFrameTime = currentTime;

                this.clearScreen();
                this.updateGameTime(currentTime); // Update time based on current frame

                const level = LEVELS[this.currentLevelIndex];
                const speedMultiplier = level ? level.speedMultiplier : 1.0;
                
                // Update and draw objects
                for (let i = this.gameObjects.length - 1; i >= 0; i--) {
                    const obj = this.gameObjects[i];
                    obj.update(speedMultiplier); 
                    obj.draw();
                    
                    if (!this.objectsAreFrozen && obj.isOffScreen()) { 
                        this.gameObjects.splice(i, 1);
                        const newFillerItem = this.getRandomFillerItem(level);
                        if (newFillerItem) {
                            this.gameObjects.push(new GameObject(newFillerItem, this.canvasWidth, this.canvasHeight));
                        }
                    }
                }
                
                // Capture effect
                if (this.captureEffect) {
                    const elapsed = currentTime - this.captureEffect.startTime;
                    const duration = 200; 
                    if (elapsed < duration) {
                        const alpha = 1 - (elapsed / duration); 
                        this.ctx.globalAlpha = alpha;
                        this.ctx.fillStyle = getCssVariable('--screen-flash-color-capture'); // Use helper
                        this.ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);
                        this.ctx.globalAlpha = 1.0;
                    } else {
                        this.captureEffect = null;
                    }
                }

                // Bonus messages
                for (let i = this.bonusMessages.length - 1; i >= 0; i--) {
                    const msg = this.bonusMessages[i];
                    const elapsed = currentTime - msg.startTime;
                    const duration = 1000; 

                    if (elapsed < duration) {
                        const alpha = 1 - (elapsed / duration);
                        this.ctx.save();
                        this.ctx.font = 'bold 24px Inter';
                        this.ctx.fillStyle = msg.color; // Already resolved in displayBonusMessage
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'bottom';
                        this.ctx.globalAlpha = alpha;
                        this.ctx.fillText(msg.text, msg.x, msg.y - (elapsed / 20)); 
                        this.ctx.restore();
                    } else {
                        this.bonusMessages.splice(i, 1);
                    }
                }

                // Highlight effect
                if (this.highlightEffect && this.highlightEffect.items.length > 0) {
                    console.log("Drawing highlight effect:", this.highlightEffect.type, this.highlightEffect.items.length, "items."); // Debug log
                    this.ctx.save();
                    this.ctx.globalAlpha = 1.0; 
                    this.ctx.lineWidth = 4;

                    for (const item of this.highlightEffect.items) {
                        if (item.obj.isVisibleOnCanvas()) { 
                            const strokeColor = getCssVariable(item.color); // Resolve CSS variable here
                            console.log(`  Highlighting ${item.obj.name} with color ${strokeColor}`); // More debug
                            this.ctx.strokeStyle = strokeColor; 
                            this.ctx.beginPath();
                            this.ctx.arc(item.obj.x, item.obj.y, item.obj.size / 2 + 10, 0, Math.PI * 2); 
                            this.ctx.stroke();
                        }
                    }
                    this.ctx.restore();
                }

                this.animationFrameId = requestAnimationFrame(this.drawGame.bind(this));
            }

            // Helper to get a random filler item (not required, not forbidden, not bonus)
            getRandomFillerItem(level) {
                // Determine all items that are explicitly 'required' or 'forbidden' in THIS level.
                const explicitlyExcludedTypes = new Set([
                    ...(level.required || []), 
                    ...(level.forbidden || []), 
                ]);

                // Filter available types to exclude those explicitly meant for specific roles (required/forbidden)
                // and any bonus items, and items with no images.
                const potentialFillerTypes = Object.keys(OBJECT_TYPES).filter(id => 
                    !explicitlyExcludedTypes.has(id) && 
                    !OBJECT_TYPES[id].isBonus && // Exclude bonus items from fillers
                    OBJECT_TYPES[id] && OBJECT_TYPES[id].img !== null
                );
                
                if (potentialFillerTypes.length === 0) {
                    console.warn("No suitable filler items available. Game might be empty or repeat specific items.");
                    // Fallback to any non-forbidden item if no true fillers
                    const fallbackFillerTypes = Object.keys(OBJECT_TYPES).filter(id => 
                        !(level.forbidden || []).includes(id) && OBJECT_TYPES[id] && OBJECT_TYPES[id].img !== null
                    );
                    if (fallbackFillerTypes.length > 0) {
                        return fallbackFillerTypes[Math.floor(Math.random() * fallbackFillerTypes.length)];
                    }
                    return null;
                }
                
                // Otherwise, pick from the available filler types
                return potentialFillerTypes[Math.floor(Math.random() * potentialFillerTypes.length)];
            }

            // --- Instructions Modal ---
            toggleInstructions() {
                this.instructionsModal.classList.toggle('hidden');
            }
        }

        // Initialize the game instance
        const gameInstance = new Game();
        document.addEventListener('DOMContentLoaded', () => gameInstance.init());

    </script>
</body>
</html>
    
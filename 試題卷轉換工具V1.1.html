<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è©¦é¡Œå·è½‰æ›å·¥å…·</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- xlsx.js for creating Excel files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- mammoth.js for reading .docx files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <!-- pdf.js for reading .pdf files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <!-- Tesseract.js for OCR on images -->
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    <!-- Google Fonts: Inter & Noto Sans TC -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Inter', 'Noto Sans TC', sans-serif;
        }
        /* Custom styles for file input */
        .file-input-label {
            transition: all 0.3s ease;
        }
        .file-input-label:hover {
            background-color: #e9ecef;
            border-color: #adb5bd;
        }
        /* Spinner animation */
        .spinner {
            border-top-color: #3498db;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-3xl bg-white rounded-2xl shadow-lg p-6 md:p-8 space-y-6">
        
        <!-- Header -->
        <div class="text-center">
            <h1 class="text-3xl font-bold text-gray-800">è©¦é¡Œå·è½‰æ›å·¥å…·</h1>
            <p class="text-gray-500 mt-2">è¼•é¬†å°‡æ‚¨çš„è©¦é¡Œè½‰æ›ç‚º Wordwall, Kahoot, å’Œ Quizizz çš„æ ¼å¼ã€‚</p>
        </div>

        <!-- Step 1: Input -->
        <div class="space-y-4">
            <h2 class="text-xl font-semibold text-gray-700 border-b pb-2">1. è¼¸å…¥è©¦é¡Œå…§å®¹</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <!-- Text Area Input -->
                <div class="space-y-2">
                    <label for="text-input" class="font-medium text-gray-600">ç›´æ¥è²¼ä¸Šæ–‡å­—:</label>
                    <textarea id="text-input" rows="10" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition" placeholder="(A) 1. é€™æ˜¯ç¬¬ä¸€é¡Œ...&#10;(A) é¸é …ä¸€ (B) é¸é …äºŒ..."></textarea>
                </div>
                <!-- File Input -->
                <div class="space-y-2">
                    <label class="font-medium text-gray-600">æˆ–ä¸Šå‚³æª”æ¡ˆ:</label>
                    <label for="file-input" class="file-input-label flex flex-col items-center justify-center w-full h-full border-2 border-dashed border-gray-300 rounded-lg cursor-pointer bg-gray-50">
                        <div class="flex flex-col items-center justify-center pt-5 pb-6">
                            <svg class="w-8 h-8 mb-4 text-gray-500" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 20 16"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 13h3a3 3 0 0 0 0-6h-.025A5.56 5.56 0 0 0 16 6.5 5.5 5.5 0 0 0 5.207 5.021C5.137 5.017 5.071 5 5 5a4 4 0 0 0 0 8h2.167M10 15V6m0 0L8 8m2-2 2 2"/></svg>
                            <p class="mb-2 text-sm text-gray-500"><span class="font-semibold">é»æ“Šä¸Šå‚³</span> æˆ–æ‹–æ›³æª”æ¡ˆè‡³æ­¤</p>
                            <p class="text-xs text-gray-500">æ”¯æ´ DOCX, PDF, PNG, JPG</p>
                        </div>
                        <input id="file-input" type="file" class="hidden" accept=".docx,.pdf,.png,.jpg">
                    </label>
                    <p id="file-name" class="text-sm text-center text-gray-500 mt-1"></p>
                </div>
            </div>
        </div>

        <!-- Step 2: AI Configuration -->
        <div class="space-y-4">
            <h2 class="text-xl font-semibold text-gray-700 border-b pb-2">2. AI è¼”åŠ© (é¸ç”¨)</h2>
            <p class="text-sm text-gray-600">å¦‚æœè‡ªå‹•è§£æå¤±æ•—ï¼Œæˆ–æƒ³å¾åœ–ç‰‡/PDFä¸­æå–æ–‡å­—ï¼Œè«‹å•Ÿç”¨ AIã€‚ç›®å‰åƒ…æ”¯æ´ Gemini API Keyã€‚</p>
            <div class="bg-gray-50 p-4 rounded-lg border">
                <div class="flex items-center space-x-4">
                    <label for="gemini-api-key" class="font-medium text-gray-700">Gemini API Key:</label>
                    <input type="password" id="gemini-api-key" class="flex-grow p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500" placeholder="è«‹è¼¸å…¥æ‚¨çš„ Gemini API Key">
                </div>
                <div class="flex justify-between items-center mt-2">
                    <p class="text-xs text-gray-500">æ‚¨çš„ API Key åªæœƒå„²å­˜åœ¨æ‚¨çš„ç€è¦½å™¨ä¸­ã€‚</p>
                    <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener noreferrer" class="text-xs text-blue-600 hover:underline font-semibold">ç”³è«‹API Key</a>
                </div>
            </div>
        </div>

        <!-- Step 3: Conversion -->
        <div class="space-y-4 text-center">
            <h2 class="text-xl font-semibold text-gray-700 border-b pb-2">3. é–‹å§‹è½‰æ›</h2>
            <button id="convert-btn" class="w-full md:w-1/2 bg-blue-600 text-white font-bold py-3 px-6 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300 transition-all duration-300 ease-in-out transform hover:scale-105">
                é–‹å§‹è½‰æ›
            </button>
        </div>

        <!-- Status & Results -->
        <div id="status-area" class="hidden text-center space-y-4 p-4 bg-blue-50 rounded-lg">
            <div class="flex items-center justify-center space-x-2">
                <div class="spinner w-6 h-6 rounded-full border-4 border-gray-200"></div>
                <p id="status-message" class="text-blue-700 font-medium">è™•ç†ä¸­...</p>
            </div>
        </div>
        
        <div id="result-area" class="hidden space-y-4">
            <h2 class="text-xl font-semibold text-gray-700 border-b pb-2">è½‰æ›çµæœ</h2>
            <div id="result-summary" class="p-4 bg-green-50 text-green-800 rounded-lg border border-green-200"></div>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                <button data-format="wordwall" class="download-btn bg-green-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-green-700 transition-all transform hover:scale-105">ä¸‹è¼‰ Wordwall æ ¼å¼</button>
                <button data-format="kahoot" class="download-btn bg-purple-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-purple-700 transition-all transform hover:scale-105">ä¸‹è¼‰ Kahoot æ ¼å¼</button>
                <button data-format="quizizz" class="download-btn bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-indigo-700 transition-all transform hover:scale-105">ä¸‹è¼‰ Quizizz æ ¼å¼</button>
            </div>
        </div>

        <!-- Credit Line -->
        <div class="text-right text-xs text-gray-400 mt-4">
            Made by Xtjh-Yuccucc
        </div>

    </div>

    <script>
        // --- DOM Elements ---
        const textInput = document.getElementById('text-input');
        const fileInput = document.getElementById('file-input');
        const fileNameDisplay = document.getElementById('file-name');
        const geminiApiKeyInput = document.getElementById('gemini-api-key');
        const convertBtn = document.getElementById('convert-btn');
        const statusArea = document.getElementById('status-area');
        const statusMessage = document.getElementById('status-message');
        const resultArea = document.getElementById('result-area');
        const resultSummary = document.getElementById('result-summary');
        const downloadButtons = document.querySelectorAll('.download-btn');

        // --- State ---
        let parsedQuestions = [];

        // --- Event Listeners ---
        fileInput.addEventListener('change', handleFileSelect);
        convertBtn.addEventListener('click', handleConversion);
        downloadButtons.forEach(btn => {
            btn.addEventListener('click', () => handleDownload(btn.dataset.format));
        });

        // --- Functions ---

        /**
         * è™•ç†æª”æ¡ˆé¸æ“‡äº‹ä»¶ï¼Œé¡¯ç¤ºæª”æ¡ˆåç¨±
         */
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                fileNameDisplay.textContent = `å·²é¸æ“‡æª”æ¡ˆ: ${file.name}`;
                textInput.value = ''; // Clear text area if file is selected
                textInput.disabled = true;
            } else {
                fileNameDisplay.textContent = '';
                textInput.disabled = false;
            }
        }

        /**
         * ä¸»è½‰æ›æµç¨‹è™•ç†å‡½æ•¸
         */
        async function handleConversion() {
            const file = fileInput.files[0];
            const text = textInput.value;
            const apiKey = geminiApiKeyInput.value.trim();

            if (!file && !text) {
                alert('è«‹è²¼ä¸Šæ–‡å­—æˆ–ä¸Šå‚³ä¸€å€‹æª”æ¡ˆï¼');
                return;
            }

            // é¡¯ç¤ºè™•ç†ä¸­ç‹€æ…‹
            showStatus('é–‹å§‹è™•ç†...');
            resultArea.classList.add('hidden');

            try {
                let extractedText = text;
                if (file) {
                    // å¦‚æœæœ‰æª”æ¡ˆï¼Œå‰‡å¾æª”æ¡ˆä¸­æå–æ–‡å­—
                    extractedText = await extractTextFromFile(file, apiKey);
                }

                if (!extractedText || extractedText.trim() === '') {
                    throw new Error("ç„¡æ³•å¾ä¾†æºæå–ä»»ä½•æ–‡å­—ã€‚");
                }

                // ç¬¬ä¸€éšæ®µï¼šä½¿ç”¨æ­£è¦è¡¨ç¤ºå¼è§£æ
                showStatus('æ­£åœ¨è§£æé¡Œç›®æ ¼å¼...');
                parsedQuestions = parseQuestionsFromText(extractedText);
                
                // å¦‚æœæ­£è¦è¡¨ç¤ºå¼è§£æå¤±æ•—ï¼Œä¸”æœ‰æä¾› API Keyï¼Œå‰‡å˜—è©¦ä½¿ç”¨ AI
                if (parsedQuestions.length === 0 && apiKey) {
                    showStatus('è‡ªå‹•è§£æå¤±æ•—ï¼Œå˜—è©¦ä½¿ç”¨ Gemini AI è¼”åŠ©...');
                    const aiFormattedText = await formatTextWithGemini(extractedText, apiKey);
                    parsedQuestions = parseQuestionsFromText(aiFormattedText);
                }

                if (parsedQuestions.length === 0) {
                    throw new Error("è§£æå¤±æ•—ï¼Œç„¡æ³•è­˜åˆ¥ä»»ä½•é¡Œç›®ã€‚è«‹æª¢æŸ¥æ‚¨çš„æ–‡å­—æ ¼å¼ï¼Œæˆ–å˜—è©¦ä½¿ç”¨ Gemini AI è¼”åŠ©ã€‚");
                }
                
                // é¡¯ç¤ºæˆåŠŸçµæœ
                showResult(parsedQuestions.length);

            } catch (error) {
                console.error('è½‰æ›éŒ¯èª¤:', error);
                showStatus(`éŒ¯èª¤: ${error.message}`, true);
            }
        }

        /**
         * æ ¹æ“šæª”æ¡ˆé¡å‹æå–æ–‡å­—
         * @param {File} file - ä½¿ç”¨è€…ä¸Šå‚³çš„æª”æ¡ˆ
         * @param {string} apiKey - Gemini API Keyï¼Œç”¨æ–¼ OCR
         * @returns {Promise<string>} - æå–å‡ºçš„æ–‡å­—
         */
        async function extractTextFromFile(file, apiKey) {
            const extension = file.name.split('.').pop().toLowerCase();
            showStatus(`æ­£åœ¨è®€å– ${extension} æª”æ¡ˆ...`);

            if (extension === 'docx') {
                const arrayBuffer = await file.arrayBuffer();
                const result = await mammoth.extractRawText({ arrayBuffer });
                return result.value;
            } else if (extension === 'pdf') {
                const pdfjsLib = window['pdfjs-dist/build/pdf'];
                pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js`;
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                let fullText = '';
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const textContent = await page.getTextContent();
                    fullText += textContent.items.map(item => item.str).join(' ') + '\n';
                }
                return fullText;
            } else if (['png', 'jpg', 'jpeg'].includes(extension)) {
                showStatus('æ­£åœ¨ä½¿ç”¨ OCR è¾¨è­˜åœ–ç‰‡ä¸­çš„æ–‡å­—...');
                const worker = await Tesseract.createWorker('eng+chi_tra');
                const { data: { text } } = await worker.recognize(file);
                await worker.terminate();
                return text;
            } else {
                throw new Error(`ä¸æ”¯æ´çš„æª”æ¡ˆæ ¼å¼: .${extension}`);
            }
        }

        /**
         * ä½¿ç”¨æ­£è¦è¡¨ç¤ºå¼å¾æ–‡å­—ä¸­è§£æå•é¡Œ
         * @param {string} text - åŒ…å«å•é¡Œçš„å®Œæ•´æ–‡å­—
         * @returns {Array<Object>} - è§£æå¾Œçš„å•é¡Œç‰©ä»¶é™£åˆ—
         */
        function parseQuestionsFromText(text) {
            const questions = [];
            // Regex to split text into question blocks. It looks for the pattern (Answer) QuestionNumber.
            const questionBlocks = text.split(/(?=\(\s*[A-D]\s*\)\s*\d+\.)/g);

            const questionRegex = /^\(\s*([A-D])\s*\)\s*(\d+)\.\s*([\s\S]*)/;
            const optionRegex = /\(([A-D])\)\s*([^()]+)/g;

            for (const block of questionBlocks) {
                if (block.trim().length === 0) continue;

                const questionMatch = block.match(questionRegex);
                if (!questionMatch) continue;

                const [, correctLetter, number, remainingText] = questionMatch;
                
                let questionText = remainingText;
                const options = [];
                let optionMatch;

                // Find where options start and separate question text from options
                const firstOptionMatch = remainingText.match(/\(A\)/);
                if (firstOptionMatch) {
                    questionText = remainingText.substring(0, firstOptionMatch.index).trim();
                    const optionsText = remainingText.substring(firstOptionMatch.index);
                    
                    while ((optionMatch = optionRegex.exec(optionsText)) !== null) {
                        options.push({
                            letter: optionMatch[1],
                            text: optionMatch[2].trim()
                        });
                    }
                }
                
                if (questionText && options.length >= 2) {
                    questions.push({
                        number: parseInt(number),
                        question: questionText,
                        options: options,
                        correctAnswer: correctLetter
                    });
                }
            }
            return questions;
        }

        /**
         * ä½¿ç”¨ Gemini API æ•´ç†æ–‡å­—æ ¼å¼
         * @param {string} rawText - åŸå§‹ã€æœªæ ¼å¼åŒ–çš„æ–‡å­—
         * @param {string} apiKey - ä½¿ç”¨è€…çš„ Gemini API Key
         * @returns {Promise<string>} - Gemini æ•´ç†å¾Œçš„æ–‡å­—
         */
        async function formatTextWithGemini(rawText, apiKey) {
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
            
            const prompt = `è«‹å°‡ä»¥ä¸‹æ–‡å­—æ•´ç†æˆæ¨™æº–çš„é¸æ“‡é¡Œæ ¼å¼ã€‚æ¯ä¸€é¡Œéƒ½å¿…é ˆä»¥ "(æ­£ç¢ºç­”æ¡ˆ) é¡Œè™Ÿ." é–‹é ­ï¼Œä¾‹å¦‚ "(A) 1."ã€‚æ¥è‘—æ˜¯é¡Œç›®å…§å®¹ï¼Œç„¶å¾Œæ˜¯é¸é …ï¼Œä¾‹å¦‚ "(A) é¸é …æ–‡å­— (B) é¸é …æ–‡å­—"ã€‚è«‹åš´æ ¼éµå®ˆæ­¤æ ¼å¼ï¼Œä¸è¦æœ‰ä»»ä½•å¤šé¤˜çš„è§£é‡‹æˆ–æ–‡å­—ã€‚é€™æ˜¯éœ€è¦æ•´ç†çš„æ–‡å­—ï¼š\n\n"${rawText}"`;

            const payload = {
                contents: [{
                    parts: [{ text: prompt }]
                }]
            };

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`Gemini API è«‹æ±‚å¤±æ•—: ${errorData.error.message}`);
            }

            const result = await response.json();
            if (result.candidates && result.candidates.length > 0) {
                return result.candidates[0].content.parts[0].text;
            } else {
                throw new Error("Gemini API æœªè¿”å›æœ‰æ•ˆçš„æ ¼å¼åŒ–æ–‡å­—ã€‚");
            }
        }

        /**
         * è™•ç†ä¸‹è¼‰è«‹æ±‚ï¼Œç”Ÿæˆå°æ‡‰æ ¼å¼çš„ Excel æª”æ¡ˆ
         * @param {string} format - 'wordwall', 'kahoot', or 'quizizz'
         */
        function handleDownload(format) {
            if (parsedQuestions.length === 0) {
                alert('æ²’æœ‰å¯ä¾›ä¸‹è¼‰çš„é¡Œç›®ï¼');
                return;
            }

            let data, header, fileName;
            const wb = XLSX.utils.book_new();

            switch (format) {
                case 'wordwall':
                    header = ['é¡Œç›®', 'ç­”æ¡ˆ', 'é¸é …2', 'é¸é …3', 'é¸é …4'];
                    data = parsedQuestions.map(q => {
                        const correctAnswerText = q.options.find(opt => opt.letter === q.correctAnswer)?.text;
                        const wrongOptions = q.options.filter(opt => opt.letter !== q.correctAnswer).map(opt => opt.text);
                        return [q.question, correctAnswerText, ...wrongOptions];
                    });
                    fileName = 'wordwall_import.xlsx';
                    break;

                case 'kahoot':
                    header = ['Question', 'Answer 1', 'Answer 2', 'Answer 3', 'Answer 4', 'Time limit (sec)', 'Correct answer(s)'];
                    data = parsedQuestions.map(q => {
                        const optionsText = q.options.map(opt => opt.text);
                        const correctIndex = q.options.findIndex(opt => opt.letter === q.correctAnswer) + 1;
                        return [
                            q.question,
                            optionsText[0] || '',
                            optionsText[1] || '',
                            optionsText[2] || '',
                            optionsText[3] || '',
                            30, // Default time updated to 30 seconds
                            correctIndex
                        ];
                    });
                    fileName = 'kahoot_import.xlsx';
                    break;

                case 'quizizz':
                    header = ['Question Text', 'Question Type', 'Option 1', 'Option 2', 'Option 3', 'Option 4', 'Correct Answer', 'Time in seconds'];
                    data = parsedQuestions.map(q => {
                        // Find the 1-based index of the correct answer
                        const correctIndex = q.options.findIndex(opt => opt.letter === q.correctAnswer) + 1;
                        return [
                            q.question,
                            'Multiple Choice',
                            q.options[0]?.text || '',
                            q.options[1]?.text || '',
                            q.options[2]?.text || '',
                            q.options[3]?.text || '',
                            correctIndex, // Use the numeric index for the correct answer
                            30 // Default time
                        ];
                    });
                    fileName = 'quizizz_import.xlsx';
                    break;
            }

            const ws = XLSX.utils.aoa_to_sheet([header, ...data]);
            XLSX.utils.book_append_sheet(wb, ws, 'Sheet1');
            XLSX.writeFile(wb, fileName);
        }

        /**
         * é¡¯ç¤ºç‹€æ…‹è¨Šæ¯
         * @param {string} message - è¦é¡¯ç¤ºçš„è¨Šæ¯
         * @param {boolean} isError - æ˜¯å¦ç‚ºéŒ¯èª¤è¨Šæ¯
         */
        function showStatus(message, isError = false) {
            statusArea.classList.remove('hidden');
            statusMessage.textContent = message;
            if (isError) {
                statusArea.classList.remove('bg-blue-50');
                statusArea.classList.add('bg-red-50');
                statusMessage.classList.remove('text-blue-700');
                statusMessage.classList.add('text-red-700');
                statusArea.querySelector('.spinner').classList.add('hidden');
            } else {
                statusArea.classList.add('bg-blue-50');
                statusArea.classList.remove('bg-red-50');
                statusMessage.classList.add('text-blue-700');
                statusMessage.classList.remove('text-red-700');
                statusArea.querySelector('.spinner').classList.remove('hidden');
            }
        }

        /**
         * é¡¯ç¤ºè½‰æ›æˆåŠŸå¾Œçš„çµæœ
         * @param {number} count - æˆåŠŸè§£æçš„é¡Œç›®æ•¸é‡
         */
        function showResult(count) {
            statusArea.classList.add('hidden');
            resultArea.classList.remove('hidden');
            resultSummary.innerHTML = `ğŸ‰ æˆåŠŸè§£æäº† <strong>${count}</strong> é“é¡Œç›®ï¼ç¾åœ¨æ‚¨å¯ä»¥ä¸‹è¼‰é©ç”¨æ–¼å„å¹³å°çš„æ ¼å¼ã€‚`;
        }

    </script>
</body>
</html>
